import re
import math
from collections import Counter


EXECUTION_PATTERNS = [
    r"eval\(",
    r"exec\(",
    r"os\.system",
    r"subprocess",
    r"CreateProcess",
    r"shell=True",
    r"powershell -enc"
]

NETWORK_PATTERNS = [
    r"http://",
    r"https://",
    r"socket",
    r"requests\.get",
    r"ftp",
    r"Invoke-WebRequest"
]

OBFUSCATION_PATTERNS = [
    r"base64",
    r"[A-Za-z0-9+/]{100,}",   # long base64 blobs
    r"chr\(",
    r"\\x[0-9a-fA-F]{2}"
]

PERSISTENCE_PATTERNS = [
    r"startup",
    r"registry",
    r"reg add",
    r"schtasks",
    r"crontab"
]


def calculate_entropy(text):
    counts = Counter(text)
    entropy = 0.0
    total = len(text)

    for c in counts.values():
        p = c / total
        entropy -= p * math.log2(p)

    return entropy


def count_matches(patterns, content):
    score = 0
    matches = []

    for pattern in patterns:
        found = re.findall(pattern, content, re.IGNORECASE)
        if found:
            score += len(found)
            matches.append(pattern)

    return score, matches


def scan_script(file_path):
    try:
        with open(file_path, "r", errors="ignore") as f:
            content = f.read()
    except:
        return {"type": "script", "error": True}

    execution_score, exec_signals = count_matches(EXECUTION_PATTERNS, content)
    network_score, net_signals = count_matches(NETWORK_PATTERNS, content)
    obf_score, obf_signals = count_matches(OBFUSCATION_PATTERNS, content)
    persistence_score, per_signals = count_matches(PERSISTENCE_PATTERNS, content)

    entropy = calculate_entropy(content)

    return {
        "type": "script",
        "execution": execution_score * 20,
        "network": network_score * 15,
        "obfuscation": obf_score * 15 + (30 if entropy > 4.5 else 0),
        "persistence": persistence_score * 20,
        "signals": exec_signals + net_signals + obf_signals + per_signals,
        "entropy": entropy
    }
